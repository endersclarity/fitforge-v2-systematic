{
  "master": {
    "tasks": [
      {
        "id": 6,
        "title": "Create Workout Template Data Structure",
        "description": "Define and implement the core data structure for workout templates (Push A/B, Pull A/B, Legs A/B) with exercise mappings",
        "details": "Create a JSON data structure defining 6 workout templates with exercise IDs mapped from the existing 38-exercise database. Include template metadata like name, description, and target muscle groups. Store in data/workout-templates.json and create TypeScript interfaces in schemas/typescript-interfaces.ts. Each template should contain: id, name, description, exercises array with exerciseId and suggested sets/reps, targetMuscles array, and estimatedDuration.",
        "testStrategy": "Validate JSON structure with schema validation, verify all exercise IDs exist in exercises-real.json, test TypeScript interfaces compile correctly, and ensure template data loads properly in components",
        "priority": "high",
        "dependencies": [],
        "status": "review",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Exercise Database and Map Categories",
            "description": "Review data/exercises-real.json to understand the 38 exercises and categorize them by movement patterns (push/pull/legs) and muscle groups",
            "dependencies": [],
            "details": "Create a mapping document that categorizes all 38 exercises into push movements (chest, shoulders, triceps), pull movements (back, biceps), and leg movements (quads, hamstrings, glutes). Note primary and secondary muscle groups for each exercise.",
            "status": "done",
            "testStrategy": "Verify that all 38 exercises are categorized and no exercise appears in multiple primary categories"
          },
          {
            "id": 2,
            "title": "Design Workout Template Schema",
            "description": "Create TypeScript interfaces for workout templates including all required fields and nested structures",
            "dependencies": [
              1
            ],
            "details": "Define interfaces in schemas/typescript-interfaces.ts for WorkoutTemplate with fields: id (string), name (string), description (string), exercises (array of {exerciseId: string, sets: number, reps: string, restSeconds: number}), targetMuscles (string[]), estimatedDuration (number in minutes), workoutType (enum: 'push' | 'pull' | 'legs'), variant ('A' | 'B')",
            "status": "done",
            "testStrategy": "Compile TypeScript to ensure interfaces are syntactically correct and properly typed"
          },
          {
            "id": 3,
            "title": "Create Push A/B Templates",
            "description": "Implement Push A and Push B workout templates with appropriate exercise selection and rep schemes",
            "dependencies": [
              1,
              2
            ],
            "details": "Push A: Focus on compound movements (bench press, overhead press) with 4-6 rep range. Push B: Include more isolation work (flyes, lateral raises) with 8-12 rep range. Each template should have 5-7 exercises with proper volume distribution.",
            "status": "done",
            "testStrategy": "Validate that Push A and B have different exercise selections with minimal overlap and appropriate volume for intermediate lifters"
          },
          {
            "id": 4,
            "title": "Create Pull A/B and Legs A/B Templates",
            "description": "Implement Pull A/B and Legs A/B workout templates following similar variation principles",
            "dependencies": [
              1,
              2
            ],
            "details": "Pull A: Vertical pulls emphasis (pull-ups, lat pulldowns). Pull B: Horizontal pulls emphasis (rows). Legs A: Quad-dominant (squats, lunges). Legs B: Hip-dominant (deadlifts, hip thrusts). Each with 5-7 exercises.",
            "status": "done",
            "testStrategy": "Ensure each template targets the intended muscle groups and follows progressive overload principles"
          },
          {
            "id": 5,
            "title": "Create and Validate workout-templates.json",
            "description": "Compile all 6 templates into data/workout-templates.json and validate against TypeScript interfaces",
            "dependencies": [
              3,
              4
            ],
            "details": "Create the JSON file with all 6 templates, ensuring proper formatting and data integrity. Include realistic estimated durations (45-75 minutes) based on exercise count and rest periods. Validate JSON structure matches TypeScript interfaces.",
            "status": "done",
            "testStrategy": "Use JSON schema validation and TypeScript type checking to ensure data consistency. Test import in a component to verify usability."
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Template Selection Interface Component",
        "description": "Create a React component for selecting from the 6 pre-built workout templates with clear visual design",
        "details": "Create components/workout-template-selector.tsx using Calm Design System tokens. Display templates in a responsive grid (2x3 or 3x2) with cards showing template name, brief description, estimated duration, and target muscles. Include hover states and selection highlighting. Use existing design patterns from equipment-filter.tsx for consistency. Implement template selection state management and onSelect callback prop.",
        "testStrategy": "Test component renders all 6 templates correctly, verify responsive layout on mobile/desktop, validate selection state management, ensure accessibility with proper ARIA labels, and test integration with parent components",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "review",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Template Data Structure and Types",
            "description": "Create TypeScript interfaces for workout templates including name, description, duration, target muscles, and exercise lists",
            "dependencies": [],
            "details": "Define interfaces in types/workout.ts or similar location. Include fields for templateId, name, description, estimatedDuration (minutes), targetMuscles (array), exerciseIds (array), difficulty level, and any metadata needed for the 6 pre-built templates",
            "status": "done",
            "testStrategy": "Verify type definitions compile correctly and can be used to create valid template objects"
          },
          {
            "id": 2,
            "title": "Create Template Card Component",
            "description": "Build a reusable TemplateCard component that displays individual workout template information with proper styling",
            "dependencies": [
              1
            ],
            "details": "Create components/template-card.tsx using Calm Design System tokens from styles/calm-tokens.css. Include template name (heading), description text, duration badge, target muscles list, hover states with elevation changes, and selection state styling. Reference equipment-filter.tsx for consistent design patterns",
            "status": "done",
            "testStrategy": "Test card renders correctly with sample data, hover states work, and selection highlighting is visible"
          },
          {
            "id": 3,
            "title": "Implement Grid Layout System",
            "description": "Create responsive grid layout for template cards that adapts between 2x3 and 3x2 configurations based on viewport",
            "dependencies": [
              2
            ],
            "details": "Use CSS Grid or Flexbox to create responsive layout in workout-template-selector.tsx. Implement breakpoints for mobile (1 column), tablet (2 columns), and desktop (3 columns). Ensure proper spacing using Calm Design tokens and maintain consistent card sizes",
            "status": "done",
            "testStrategy": "Verify grid responds correctly at different viewport sizes and maintains proper spacing"
          },
          {
            "id": 4,
            "title": "Add Selection State Management",
            "description": "Implement state management for template selection with proper React hooks and callback handling",
            "dependencies": [
              3
            ],
            "details": "Use useState hook to track selected template ID, implement click handlers on template cards, ensure only one template can be selected at a time, add visual feedback for selected state, and create onSelect callback prop that passes selected template data to parent component",
            "status": "done",
            "testStrategy": "Test single selection behavior, verify onSelect callback fires with correct template data"
          },
          {
            "id": 5,
            "title": "Create Mock Template Data and Integration",
            "description": "Generate mock data for the 6 workout templates and integrate the complete selector component",
            "dependencies": [
              4
            ],
            "details": "Create mock data file with 6 diverse workout templates (e.g., Upper Body Power, Lower Body Strength, Full Body HIIT, Core & Cardio, Push/Pull Split, Beginner Basics). Each should have realistic names, descriptions, durations (30-90 min), and target muscle groups. Export WorkoutTemplateSelector component with proper props interface",
            "status": "done",
            "testStrategy": "Verify all 6 templates display correctly, selection works for each template, and component integrates smoothly with parent components"
          }
        ]
      },
      {
        "id": 8,
        "title": "Redesign Dashboard Navigation to Workout-Centric Model",
        "description": "Replace muscle group cards with action-focused navigation emphasizing workout templates and core actions",
        "details": "Update components/fitbod-home.tsx to remove muscle group navigation cards and replace with workout-centric actions: 'Start Workout' (leads to template selection), 'Plan Workout' (advanced builder), 'View History', 'Body Stats'. Use existing Calm Design System for consistency. Maintain the workout logger enhanced component integration but change entry points to be template-driven. Keep existing localStorage integration intact.",
        "testStrategy": "Verify muscle group cards are completely removed, test all navigation actions work correctly, ensure existing localStorage functionality remains intact, validate responsive design, and confirm workout logger integration still functions",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Template-to-Builder Integration",
        "description": "Create seamless data flow from template selection to existing workout builder with pre-populated exercises",
        "details": "Modify components/workout-builder.tsx to accept template data as props and pre-populate with template exercises. Create utility functions in lib/ to transform template data into workout builder format. Ensure existing equipment filtering and muscle volume visualization continue to work with template-sourced exercises. Implement URL routing or state management to pass template selection context to builder.",
        "testStrategy": "Test template data correctly populates workout builder, verify equipment filtering works with template exercises, ensure muscle volume visualization displays correctly, test navigation flow from template selection to builder, and validate existing builder functionality remains unchanged",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Template Data Transformation Utilities",
            "description": "Build utility functions to convert workout template data structure into the format expected by workout-builder.tsx",
            "dependencies": [],
            "details": "Create lib/template-utils.ts with functions like templateToWorkoutBuilder() that transform template exercises (with their sets, reps, equipment) into the WorkoutExercise format used by the builder. Handle mapping of exercise IDs, equipment requirements, and default set/rep schemes.",
            "status": "pending",
            "testStrategy": "Unit test transformation functions with sample template data to ensure correct mapping of all fields and edge cases like missing equipment or invalid exercise IDs"
          },
          {
            "id": 2,
            "title": "Add Template Props to Workout Builder Component",
            "description": "Modify workout-builder.tsx to accept optional template data as props and implement initialization logic",
            "dependencies": [
              1
            ],
            "details": "Update WorkoutBuilder component interface to accept templateData prop. Add useEffect hook to detect template data and call transformation utilities to pre-populate the workout. Ensure this doesn't interfere with existing empty workout initialization.",
            "status": "pending",
            "testStrategy": "Test component renders correctly with and without template data, verify pre-population works and existing features remain functional"
          },
          {
            "id": 3,
            "title": "Implement Template Selection State Management",
            "description": "Create state management solution to pass selected template from selection interface to workout builder",
            "dependencies": [],
            "details": "Implement either URL-based routing with query parameters (e.g., /workout-builder?template=strength-basics) or React Context/Zustand store to maintain selected template state. Include mechanism to clear template selection after use.",
            "status": "pending",
            "testStrategy": "Verify state persists across navigation, template data is accessible in workout builder, and state clears appropriately"
          },
          {
            "id": 4,
            "title": "Update Template Selection Interface Integration",
            "description": "Connect template selection component to trigger navigation/state update when template is selected",
            "dependencies": [
              3
            ],
            "details": "Modify template selection component's onSelect handler to either navigate to workout builder with template parameter or update global state. Add loading states and error handling for template data retrieval.",
            "status": "pending",
            "testStrategy": "E2E test selecting a template and verifying workout builder receives and displays the correct template data"
          },
          {
            "id": 5,
            "title": "Ensure Equipment Filter and Muscle Volume Compatibility",
            "description": "Verify and fix any issues with equipment filtering and muscle volume visualization when using template-sourced exercises",
            "dependencies": [
              2,
              4
            ],
            "details": "Test that equipment filters properly filter template exercises, muscle volume calculations include all template exercises, and the visualization updates correctly. Fix any edge cases where template data structure differs from manually added exercises.",
            "status": "pending",
            "testStrategy": "Integration test with various templates containing different equipment requirements and muscle groups, verify filters and visualizations work correctly"
          },
          {
            "id": 6,
            "title": "🔍 CHECKPOINT: User can verify template data transforms correctly",
            "description": "User opens browser console at localhost:8080, selects a template, and sees properly formatted workout queue data logged to console before navigation",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 7,
            "title": "🔍 CHECKPOINT: User can see template selection actually navigates to workout logging",
            "description": "User clicks Start Workout → selects any template → clicks Start Workout → should navigate to /workouts-simple with working exercise list (no more alert popup)",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 8,
            "title": "🔍 CHECKPOINT: User can complete end-to-end workout session from template",
            "description": "User selects template → starts workout → logs multiple sets → finishes workout → sees completed session saved to localStorage. Full functional flow working.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Rest Timer Component with Customizable Duration",
        "description": "Create a rest timer that automatically starts after set completion with customizable duration and localStorage persistence",
        "details": "Create components/rest-timer.tsx with countdown display, pause/resume functionality, and audio/visual completion notification. Default to 60-90 seconds with user customization. Store timer preferences in localStorage. Integrate with WorkoutLoggerEnhanced component to auto-start after set completion. Include circular progress indicator and prominent time display using Calm Design System typography and colors.",
        "testStrategy": "Test timer accuracy and precision, verify localStorage persistence of preferences, validate auto-start integration with set completion, test pause/resume functionality, ensure responsive design, and verify completion notifications work properly",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Add Visual Progress Indicators for Set Completion",
        "description": "Implement real-time visual progress tracking showing completed vs remaining sets with clear status indicators",
        "details": "Enhance components/workout-logger-enhanced.tsx with progress indicators showing: completed sets (green checkmarks), current set (highlighted), remaining sets (outlined). Add overall workout progress bar showing percentage completion across all exercises. Use existing Calm Design System colors and implement smooth transitions for state changes. Include numerical progress display (e.g., '3 of 12 sets complete').",
        "testStrategy": "Test progress indicators update correctly when sets are completed, verify visual consistency with design system, validate smooth transitions and animations, test overall progress calculation accuracy, and ensure indicators work across different screen sizes",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Optimize Set Completion User Experience Flow",
        "description": "Streamline the workout logging interaction for faster, more intuitive set completion with immediate feedback",
        "details": "Refactor WorkoutLoggerEnhanced set completion to single-tap interaction with immediate visual feedback. Implement optimistic UI updates, large touch targets for mobile use, and clear completion animations. Add undo functionality for accidental completions. Ensure weight/rep entry is streamlined with number pad optimization and smart defaults based on previous sets.",
        "testStrategy": "Test single-tap completion works reliably, verify immediate visual feedback, validate undo functionality, test touch target sizes on mobile devices, ensure optimistic UI updates don't cause data inconsistencies, and verify accessibility compliance",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Relocate Equipment Filters to Exercise List Pages",
        "description": "Move equipment filtering from workout builder to exercise list pages with horizontal filter bar layout",
        "details": "Move components/equipment-filter.tsx to exercise list pages (app/exercises/[muscleGroup]/page.tsx). Redesign as horizontal filter bar with multiple filter options: All, Equipment, Target Muscle, Available Equipment. Maintain existing equipment filtering logic but adapt UI for horizontal layout. Ensure filter state persists across page navigation using localStorage or URL parameters.",
        "testStrategy": "Test equipment filters work correctly on exercise list pages, verify horizontal layout is responsive, validate filter state persistence across navigation, ensure existing equipment filtering logic remains functional, and test filter combination behavior",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Muscle Fatigue Intelligence Algorithm",
        "description": "Create intelligent exercise ordering based on muscle recovery analysis from recent workout history",
        "details": "Create lib/muscle-fatigue-intelligence.ts with algorithm to analyze recent workout data and calculate muscle recovery states. Use existing muscle engagement percentages from exercises-real.json to determine muscle load. Implement 48-72 hour recovery windows per muscle group. Create scoring system to prioritize exercises targeting recovered muscles over fatigued ones. Integrate with exercise list sorting.",
        "testStrategy": "Test algorithm correctly calculates muscle fatigue from workout history, verify recovery time calculations are accurate, validate exercise prioritization logic, test with various workout history scenarios, and ensure performance with large datasets",
        "priority": "low",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Add Enhanced Filter Options with Muscle Fatigue Integration",
        "description": "Expand filter options to include muscle fatigue-based filtering and intelligent exercise discovery",
        "details": "Extend horizontal filter bar to include 'Muscle Fatigue' filter option that shows exercises targeting recovered muscles first. Update filter logic to support multiple simultaneous filters (Equipment + Fatigue, Target Muscle + Available Equipment). Implement filter chips UI showing active filters with easy removal. Ensure filter combinations work logically together and provide meaningful exercise subsets.",
        "testStrategy": "Test all filter combinations work correctly, verify muscle fatigue filtering produces logical results, validate multiple filter selection UI behavior, test filter chip removal functionality, ensure filter logic performance with complex combinations, and verify user experience is intuitive",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create FitForge Splash Screen with Intake Flow Detection",
        "description": "Build a colorful splash screen that checks localStorage for user profile data and routes to intake form or main app accordingly.",
        "details": "Create app/page.tsx as the root splash screen component displaying the colorful splash image from public/splashscreen_bunq.png. Implement localStorage check for user profile data with console logging for debugging. Create routing logic that navigates to intake form if no profile exists, or main app if profile is found. Reference flows/logging-in/flow-analysis.md for design patterns and user flow insights. Implement polished transitions using CSS animations or Framer Motion. Add loading states and error handling for localStorage access. Ensure responsive design works across mobile and desktop viewports using Calm Design System tokens.",
        "testStrategy": "Test user sees colorful splash image at localhost:8080 on page load, verify routing logic outputs to console showing profile check results, test user with empty localStorage gets routed to intake form, test user with existing profile data gets routed to main app, validate smooth transitions between splash and target screens, test responsive design on various screen sizes, and ensure accessibility compliance with proper alt text and ARIA labels",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Splash Screen Component with Image Display",
            "description": "Build the root app/page.tsx component that displays the colorful splash image from public/splashscreen_bunq.png with proper styling and responsive design",
            "dependencies": [],
            "details": "Create app/page.tsx as the main entry point. Import and display the splash image using Next.js Image component. Apply CSS styling using Calm Design System tokens from styles/calm-tokens.css for consistent theming. Ensure the splash screen fills the viewport and looks good on mobile and desktop. Add initial mounting animation for smooth appearance.",
            "status": "done",
            "testStrategy": "Verify splash screen renders correctly at localhost:8080, test responsive behavior at different viewport sizes, confirm image loads properly"
          },
          {
            "id": 2,
            "title": "Implement LocalStorage Profile Detection Logic",
            "description": "Add functionality to check localStorage for existing user profile data with proper error handling and console logging for debugging",
            "dependencies": [
              1
            ],
            "details": "Within app/page.tsx, implement useEffect hook to check localStorage for user profile data on component mount. Add try-catch blocks for safe localStorage access. Include detailed console.log statements showing profile check results. Define the expected profile data structure based on existing app patterns.",
            "status": "done",
            "testStrategy": "Test with and without profile data in localStorage, verify console logs show correct detection results, confirm error handling works when localStorage is unavailable"
          },
          {
            "id": 3,
            "title": "Create Routing Logic for Conditional Navigation",
            "description": "Implement navigation logic that routes users to either the intake form or main app based on profile existence",
            "dependencies": [
              2
            ],
            "details": "Use Next.js useRouter to handle navigation after profile check completes. Route to intake form path if no profile exists, or to main app dashboard if profile is found. Add a delay to ensure splash screen is visible for at least 2-3 seconds for better UX. Handle edge cases like corrupted profile data.",
            "status": "done",
            "testStrategy": "Test navigation flows both with and without profile data, verify correct routing destinations, ensure navigation timing feels natural"
          },
          {
            "id": 4,
            "title": "Add Loading States and Transition Animations",
            "description": "Implement smooth transitions and loading indicators during the profile check and navigation process",
            "dependencies": [
              3
            ],
            "details": "Add loading state management using React state hooks. Implement fade-out animation for splash screen before navigation using CSS transitions or Framer Motion. Show subtle loading indicator during localStorage check if needed. Ensure transitions follow patterns from flows/logging-in/flow-analysis.md for consistency.",
            "status": "pending",
            "testStrategy": "Verify smooth visual transitions between states, test animation performance on different devices, ensure no jarring visual jumps"
          },
          {
            "id": 5,
            "title": "Polish Error Handling and Edge Cases",
            "description": "Add comprehensive error handling for localStorage failures and implement fallback behaviors for edge cases",
            "dependencies": [
              4
            ],
            "details": "Handle scenarios where localStorage is disabled or throws exceptions. Add fallback navigation to intake form if profile check fails. Implement timeout handling if localStorage operations take too long. Add user-friendly error states that maintain the visual polish of the splash screen. Log all errors to console for debugging.",
            "status": "pending",
            "testStrategy": "Test with localStorage disabled, simulate slow localStorage operations, verify graceful degradation in error scenarios"
          },
          {
            "id": 6,
            "title": "🔍 CHECKPOINT: User sees colorful splash image at localhost:8080",
            "description": "User navigates to localhost:8080 and sees the rainbow splash screen image displayed properly with responsive design",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 16
          }
        ]
      },
      {
        "id": 17,
        "title": "Create Master Roadmap with Phase Overview and Development Strategy",
        "description": "Develop a comprehensive master roadmap document that provides navigable overview of all 5 development phases, architectural decisions, and migration strategies to avoid re-reading the full Development Guide.",
        "details": "Create flows/memory-bank/master_roadmap.md as the central navigation document for the entire FitForge development lifecycle. Structure with 5 main sections: Phase 1 (Foundation/Templates) covering basic workout functionality and template system, Phase 2 (Enhanced UX) for improved user interactions and flows, Phase 3 (Intelligence) introducing AI-driven exercise recommendations, Phase 4 (Advanced Analytics & AI) with comprehensive muscle fatigue analytics, and Phase 5 (Backend Integration) for database migration and cloud services. Each phase section should include: key objectives, architectural decision points, success criteria, estimated timeline, task dependencies, and specific references to Development Guide sections. Include migration strategy section detailing localStorage to database transition plan with data preservation approach. Add cross-reference table mapping current tasks to their respective phases and a quick-start navigation index for developers. Use clear markdown formatting with collapsible sections and internal linking for easy navigation.",
        "testStrategy": "Verify roadmap accurately represents all 5 phases from Development Guide, validate all internal links work correctly, ensure task-to-phase mappings are accurate by cross-referencing existing tasks, test document navigation flow provides clear path finding, verify architectural decision points align with technical requirements, and confirm migration strategy is technically feasible and includes data preservation steps",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Phase 4: Advanced Analytics & AI Implementation",
        "description": "Implement sophisticated muscle recovery analytics, AI-powered workout generation, and progressive overload optimization with real-time fatigue visualization and intelligent exercise recommendations.",
        "details": "Create comprehensive analytics system with multiple components: 1) Muscle Recovery Model (lib/muscle-recovery-model.ts) implementing 5-day recovery tracking with 48-72 hour windows per muscle group using engagement percentages from exercises-real.json. 2) AI Workout Generator (lib/ai-workout-generator.ts) that considers user profile, available equipment, muscle recovery states, and progressive overload principles to generate optimal workouts. 3) Progressive Overload Optimizer (lib/progressive-overload.ts) with algorithms for 3% volume increases through weight/rep adjustments based on performance history. 4) Advanced Fatigue Calculator (lib/advanced-fatigue-calculator.ts) using scientific muscle engagement data to calculate precise fatigue scores across all muscle groups. 5) Real-time Muscle Heat Map (components/muscle-heat-map.tsx) with SVG anatomical visualization showing color-coded fatigue states. 6) Intelligent Workout Suggestions (lib/intelligent-suggestions.ts) that analyzes equipment availability, muscle recovery, and user goals to recommend optimal exercise selection and ordering. Integrate all components with existing workout builder and logger systems while maintaining performance with localStorage data persistence.",
        "testStrategy": "Test muscle recovery calculations accurately reflect 48-72 hour windows and engagement percentages from exercise data. Verify AI workout generator produces logical workouts considering all input parameters (profile, equipment, recovery, progressive overload). Validate progressive overload algorithms correctly calculate 3% volume increases and track performance trends. Test advanced fatigue calculator produces consistent and accurate muscle fatigue scores. Verify muscle heat map renders correctly with real-time updates and proper color coding for different fatigue levels. Test intelligent suggestions provide relevant and achievable exercise recommendations. Ensure all analytics components integrate seamlessly with existing workout builder and logger without performance degradation. Validate localStorage persistence of analytics data and recovery state across sessions.",
        "status": "pending",
        "dependencies": [
          6,
          7,
          9,
          11,
          14
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Phase 5: Backend Integration & Sync Implementation",
        "description": "Migrate from localStorage to Supabase PostgreSQL with FastAPI backend, implementing real-time sync, authentication, and production-ready architecture.",
        "details": "Implement comprehensive backend integration in multiple stages: 1) Database Schema Migration - Create PostgreSQL schemas matching existing localStorage data structures (users, workouts, exercises, templates) with proper foreign key relationships and indexes. 2) Supabase Setup - Configure Supabase project with Row Level Security policies, authentication providers, and real-time subscriptions. 3) FastAPI Backend - Build Python API with SQLAlchemy ORM, Pydantic validation schemas, and endpoints for all workout operations (CRUD for workouts, templates, user profiles). 4) Authentication Integration - Implement Supabase Auth with email/password and social providers, protecting all API routes. 5) Data Migration Utilities - Create migration scripts to transfer existing localStorage data to PostgreSQL without data loss. 6) Real-time Sync - Implement WebSocket connections for live workout updates across devices using Supabase real-time subscriptions. 7) Offline Support - Add service workers and local caching for offline functionality with sync on reconnection. 8) Enhanced Error Handling - Implement comprehensive error boundaries, retry logic, and user-friendly error messages. 9) Production Deployment - Set up Docker containers, environment configuration, and CI/CD pipeline for professional deployment. Use existing TypeScript interfaces from Task 6 as foundation for backend schemas.",
        "testStrategy": "Test database schema creation and data integrity with foreign key constraints. Verify data migration preserves all localStorage workout history and user profiles without corruption. Test authentication flows including registration, login, logout, and password reset. Validate all API endpoints with proper error handling and status codes. Test real-time sync across multiple browser sessions and devices. Verify offline functionality works correctly with data sync on reconnection. Test Row Level Security policies prevent unauthorized data access. Validate WebSocket connections handle disconnections gracefully. Test production deployment with load testing and monitoring. Ensure all existing frontend functionality continues to work with new backend integration.",
        "status": "pending",
        "dependencies": [
          6,
          7,
          9,
          11,
          16,
          17,
          18
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create Custom Framer Motion Flowing Menu Component",
        "description": "Build a sophisticated Framer Motion flowing menu component for dashboard navigation that replicates ReactBits flowing menu effects with edge detection, marquee scrolling, and smooth hover transitions without GSAP dependency.",
        "details": "Create components/flowing-menu.tsx implementing a custom flowing menu system using Framer Motion library. Key features: 1) Edge Detection - Implement directional slide animations that detect menu position relative to viewport edges and adjust animation direction accordingly. 2) Marquee Scrolling - Create smooth horizontal text scrolling effects for menu items with overflow content using Framer Motion's useAnimation and useMotionValue hooks. 3) Hover Transitions - Implement fluid hover states with scale, opacity, and color transitions using Framer Motion variants. 4) Dashboard Integration - Connect menu to existing dashboard card navigation system from components/dashboard-cards.tsx, maintaining current routing while enhancing visual experience. 5) Performance Optimization - Use Framer Motion's layout animations and will-change CSS properties for smooth 60fps animations. 6) Responsive Design - Ensure menu adapts to mobile/desktop viewports with appropriate touch gestures. Use existing Calm Design System tokens for colors, spacing, and typography consistency. Menu should trigger on card hover/focus and provide contextual navigation options.",
        "testStrategy": "Test edge detection correctly identifies viewport boundaries and adjusts animation directions (top/bottom/left/right edge scenarios). Verify marquee scrolling works smoothly with various text lengths and stops appropriately on hover. Validate hover transitions are fluid and performant across different devices and browsers. Test integration with existing dashboard cards maintains current navigation functionality while adding visual enhancements. Verify menu positioning is accurate relative to trigger elements. Test responsive behavior on mobile devices with touch interactions. Measure animation performance to ensure consistent 60fps frame rate. Test accessibility with keyboard navigation and screen readers.",
        "status": "in-progress",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-25T16:20:00.000Z",
      "updated": "2025-06-26T01:24:23.013Z",
      "description": "Tasks for master context"
    }
  }
}